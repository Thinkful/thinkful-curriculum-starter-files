<!-- 
name: Working with PostgreSQL
author: Iain Duncan
type: content
time:
 -->
In Lesson 1 of this Unit, we gained a good grasp of the basics of SQL. We built a database using SQLite and interacted with it using the sqlite3 console. In this assignment, we'll cover the essential things you need to know as you switch over to working PostgreSQL. 

In this document we'll follow the convention of writing SQL keywords (e.g., SELECT, FROM, WHERE) in all caps, and referring to table and column names in lower case. Remember though that when it comes to keywords (**not** table and column names!), SQL is not case sensitive, so it is not mandatory to put use uppercase. That being said, using uppercase for SQL keywords is considered best practice, as  you don't have to do this yourself. 
However, it does make seeing the differences easier at a glance, so we'll use
it here. 

To begin with, let's look at the differences between SQLite and PostGreSQL and
get our PostgreSQL database up and running. 



SQLite vs PostgreSQL
--------------------

PostGreSQL is an industrial strength open source RDBMS used for mission critical, high bandwidth applications all over the world. PostgreSQL provides built in support for database constraints by default, whereas in SQLite, one has to enable constraints. Running without constraints is convenient for learning, prototyping,
or even for embedding for
single user applications, but for real world multi-user situations you are 
well advised to set up constraints as well as you can to ensure database integrity.

This means that we'll have require additional SQL for creating our tables. We're
going to revisit our pet database construction now to add these constraints.
We'll be adding foreign key constraints forcing our foreign keys to have valid
values. We'll also be enforcing uniqueness on columns that shouldn't have
duplicate values, and we'll be using PostgreSQL's **sequence*** feature to
have PostgreSQL automatically create sequential integer primary keys for us.


Primary Keys and Sequences
--------------------------
When using a database in a multi-user context, it's usually a good idea to
leave the generation of integer primary keys (our 'id' columns) up to the 
RDBMS, unless you know exactly why you want to do it yourself. (You'll
know when you're qualifed to break these sorts of guidelines!)
We want to be able to insert records without specifying the key, like so ::

    INSERT INTO breed (name) VALUES ('Persian'),('Tabby'),('Mixed');

Note we are leaving out the id column from both sides of our query. There
are a couple of ways of making this work properly in PostgreSQL. The one
we're going to use is the *sequence* command. Our Species table creation will
now look like this ::

    CREATE SEQUENCE species_id_seq;
    CREATE TABLE species (
        id INTEGER PRIMARY KEY DEFAULT NEXTVAL('species_id_seq'),
        name TEXT NOT NULL
        );
    ALTER SEQUENCE species_id_seq OWNED BY species.id;

The first line creates a a new *sequence* and names it species_id_seq.
The sequence is a stand-alone entity that creates sequential values.
In the definition of the 'id' column, we see the addition of 
**default nextval('species_id_seq')**. This means that if no value is 
given, PostgreSQL will automatically insert the next integer value from
the sequence for us. Finally, the last statement sets the sequence
as owned by the species.id column, which means that if the
species table is dropped, this sequence will be dropped as well. 

An important side effect of this is that we should not mix explicit
generation of primary key values with use of the sequence, or the sequence will
get out of sequence. I.E: if we create a record, generating the id
ourselves, and then subsequently create a record without specifiying 
the id, we'll get an error as the sequence will try to create a duplicate
id. There are advanced techniques to get around this issue, but
we'll use the practise of *always* letting the RDBMS determine
our primary keys.


Foreign Key Constraints
-----------------------
Next we'll look at our Breed table, which has a foreign key to the
species table id :: 

    CREATE SEQUENCE breed_id_seq;
    CREATE TABLE breed (
        id INTEGER PRIMARY KEY DEFAULT NEXTVAL('breed_id_seq'),
        name TEXT NOT NULL,
        species_id INTEGER REFERENCES species(id)
        );
    ALTER SEQUENCE breed_id_seq OWNED BY breed.id;

In this table we see the addition to the species_id column of 
"references species(id)". This will enforce the constraint
that species_id can *only* hold a valid value from the species table's
id column.
This has some strict side effects: We can't delete an entry from the species
table as long as there is still an entry in the breed table that references
the entry we're trying to delete. The RDBMS won't let us and will 
give us back an error message. If we want to change our constraint
rules so that we *can* delete a species and all the breeds associated
with it are also deleted, we can add cascading rules in our CREATE
TABLE statement ::

    species_id INTEGER REFERENCES species(id) ON DELETE CASCADE

Alternately we can add a constraint to instead set the orphans
to have null values when the item they reference is deleted ::

    species_id INTEGER REFERENCES species(id) ON DELETE NULL

Further details on constraint options are in the official
PostgreSQL docs for Create Table: 
http://www.PostgreSQLql.org/docs/9.0/static/sql-createtable.html

This also affects dropping tables. PostgreSQL won't let us 
drop a table if it violates the same rules. This means that
if we want to drop and recreate our tables, we need to pay attention
to the order of the tables when dropping. We would drop
in the reverse of our creation order:
    
    pet_person
    pet 
    breed
    species


Many-To-Many Tables
-------------------
For Many-To-Many tables, we'll use the foreign key definitions
we've just discussed, and also add a primary key constraint
to let PostgreSQL know that the combination of the two foreign
keys is our primary key and thus must be unique ::

    CREATE TABLE pet_person (
        pet_id INTEGER REFERENCES pet(id),
        person_id INTEGER REFERENCES person(id),
        PRIMARY KEY (pet_id, person_id)
    );

Now if we try to make a duplicate entry, we'll get an error.

The above definition again means that if we try to delete
a pet, and there is a record in pet_person referencing this
pet, we'll get an error. In this case, that doesn't make much 
real world sense: probably shouldn't have to orphan pets before
deleting them. So we'll add cascade rules to delete our many-to-many 
records if either pets or people are deleted ::

    CREATE TABLE pet_person (
        pet_id INTEGER REFERENCES pet(id) ON DELETE CASCADE,
        person_id INTEGER REFERENCES person(id) ON DELETE CASCADE,
        PRIMARY KEY (pet_id, person_id)
    );


Uniqueness
----------
PostgreSQL will automatically enforce uniqueness for anything
we declare as a primary key. We can also enforce uniqueness
for additional columns beyond primary keys. For example, perhaps we want to 
enforce that there be no duplicate first and last name combinations
in our person table, and no duplicate email addresses ::

    CREATE TABLE person (
        id INTEGER PRIMARY KEY DEFAULT NEXTVAL('person_id_seq'),
        first_name TEXT NOT NULL,
        last_name TEXT NOT NULL,
        email TEXT,
        
        UNIQUE( first_name, last_name),
        UNIQUE( email )
    );


Inserting Records with Foreign Keys
-----------------------------------

One wrinkle we have now that we've defined our tables with
foreign key references is that we can no longer do this ::

    insert into species (id, name) values (1, 'Cat');

    insert into breed (id, name, species_id) values
        (1, 'Persian', 1);

Because we're leaving key generation up the RDMBS, we now
use a subquery for inserting our foreign keys when we're
populating the database with sample data ::

    insert into species (name) values ('Cat');

    insert into breed (name, species_id) values 
        ('Persian', (select id from species where name='Cat') );


Next Steps
----------
This should cover us for getting our database converted over
to PostgreSQL. Download the starter file for
creating our PostgreSQL verions of our pets database and
get it loaded with pqsl. We can do this by redirecting the SQL file
into pqsl ::

    psql -d pets < pets_PostgreSQLql.sql

Before proceeding to the next assignment, make sure your
new database is working by connecting to it with psql and
issuing some queries :: 

    $ psql
    psql> \connect pets
    psql> select * from species;
    ... etc ...

Like SQLite, PostgreSQL has its own specific commands that
are not terminated with a semicolon. In PostgreSQL, these
start with a \. Here are a few you'll want while using psql

    \connect pets
        connect to pets database
    \dt
        list all tables
    \d+
        list all tables and sequences
    \d+ pet 
        describe the pet table in detail
    \q
        quit
    \?      
        show help
     

(TODO: have them download the PostgreSQL starter file)
Download the file pets_PostgreSQLql.sql or whatever it will
be called.
