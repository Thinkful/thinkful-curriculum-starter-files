<!-- 
name: Up and Running with SQLite
author: Iain Duncan
type: task
time: 60 minutes
 -->
In this short assignment, we'll get SQLite up and running. As we learned in the introduction to this unit, SQLite stores the entire database in one file, so all we need in order to use it is a program that can read and write this file properly. For this, we'll use the terminal application **sqllite3**.

# Installing SQLite

To find out if SQLite is already installed on your system, from the command line run `sqlite3`. If you see an output like the one below, SQLite is already installed in your system.

```bash
    $ sqlite3 
    SQLite version 3.8.3.1 2014-02-11 14:52:19
    Enter ".help" for instructions
    Enter SQL statements terminated with a ";"
    sqlite> 
```

If you see an output like this, you're good to go, and you can exit the sqlite console by entering the command `.quit` or `Control-D`. However, if you get an error message indicating that the sqlite3 command is not found, you'll need to install the sqlite terminal application. To do this head over to the [download page](http://www.sqlite.org/download.html) of the SQLite web page and download and install the right binary for your system.

If you've worked with a regular database system before, you may be wondering 
when and where you install the database server. SQLlite doesn't use a server application, as the whole works are contained in one file. All you need to do to interact with an SQLite database is to install either the terminal application, or else install and use the sqlite3 library for Python. SQLlite can even use an in-memory database that will cease to exist when you exit
your application (if you start SQLite without a file name, it will open a session with a temporary in-memory database).


# First Taste of SQL and SQLite

When we work with any RDBMS, there are two dialects that we can use to talk
to the database: vendor neutral SQL, and vendor specific commands for the
database system. We'll be using vendor neutral SQL to create, delete, and edit tables and to select or update rows within those tables. We'll use the vendor-specific SQLlite commands to list all the tables in the database and to see
the details of a table's structure.

SQL commands are case insensitive and always end with a semi-colon; a command can span multiple lines and does not get terminated until a semi-colon is entered. SQLite specific commands, in contrast, begin with a period and are ended with a carriage-return (as we saw with the `.quit` command earlier). Confusing these two sorts of commands is common source of confusion and frustration for new users.

Let's create a small, scratch database to get an initial sense of how to work with SQLite. First, create a new folder somewhere on your computer called 'sqlitedemo'. We'll delete this folder after this assignment. Next, open a new file in your text editor, and paste in the following code:

```sql
drop table if exists person;

create table person (
    id int primary_key not null,
    name text not null,
    age  int 
);

insert into pet values 
    (1, 'Bob', 22),
    (2, 'Sue', 34),
    (3, 'Timmy', 19),
    (4, 'Ellen', 24);
```

Save this file as *person-demo.sql* inside of the *sqlitedemo* folder you just created. By the end of this lesson, you'll understand exactly what this code does. For now, just know that this is SQL (*not* vendor specific code) that creates a new database and inserts 4 records into it. 

Now we're going to run this sql from the command line. From your terminal, navigate to your *sqlitedemo* folder. Then run the following command: `sqlite3 -echo person-demo.db < person-demo.sql`. You should get the following output:

```sql
drop table if exists person;
create table person (
    id int primary_key not null,
    name text not null,
    age  int 
);
insert into person values 
    (1, 'Bob', 22),
    (2, 'Sue', 34),
    (3, 'Timmy', 19),
    (4, 'Ellen', 24);
```

This output indicates the commands that SQLite has executed. As you can see, these are precisely the same commands we specified in our *person-demo.sql* file a moment ago. Note that if we had run the previous command as `sqlite3 person-demo.db < person-demo.sql` without the `-echo` option, even though we would have successfully created our database, we would have gotten no output to our terminal window. 

The command we just ran intitialized a new database named "person-demo" in the current directory. You can see this by running `ls` in the person-demo directory, which will reveal a new file called 'person-demo.db'. Note that when you run the command `sqlite3 some-db-name.db`, sqlite will open with the named database if it already exists; otherwise it will create it in the current working directory. 

One final thing to note about the command above is the use of the redirection operator `<` along with a file name. Given a file of SQL commands, the redirection operator will route those commands into the database file it points to. This is called an **SQL dump**, and it's a commonly used, cross-platform method for storing or restoring the contents of a complete database. 

Now let's open the sqlite3 console and run a few commands in there. From the command line, still in the sqlitedemo folder, run `sqlite3 person-demo.db`. You should see an output like this:

```bash
SQLite version 3.7.13 2012-07-17 17:46:21
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite> 
```

From the sqlite prompt, we can now execute vendor-specific and SQL code. 

Let's have a look at the tables in the database by running the `.tables` command. Since we've only created a single table in this databse ('person'), you should get an output like this:

```bash
    sqlite> .tables
    person
    sqlite> 
```

To see the details for a specific table, we use the `.schema` command. Our db only has the person table, so to see its details, we run `.schema person`, which should give us the following output: 

```sql
sqlite> .schema person
CREATE TABLE person (
    id int primary_key not null,
    name text not null,
    age  int 
);
```

As you can see, this gives us the command that was used to create the table, and from that we can see which column names we have and their type.

To see all of the available SQLite commands, run the `.help` command in the sqlite console. 

We just saw that we can use the redirection operator to create or restore a database from an SQL file. We can also use the redirection operator in combination with the `.dump` command to dump the contents of an existing database into a raw SQL file of commands that, if run, will create all of the tables and records in our database. Let's try that by running the following command from your terminal, still in the sqlitedemo folder: `sqlite3 person.db .dump > person_dump.sql`. Note that in this case, we're pointing the redirection operator in the opposite direction, to port our SQL commands into the file "pet_dump.sql". 

That command will create a new file called 'pet_dump.sql' in the current directory. We can look at the contents of this file by running `cat person_dump.sql`.

We're almost ready to move on to *SQL The Hard Way* in the next few assignments, but first, let's get a quick taste of how we can query the records in a table. Again from the command line and the sqlitedemo folder, run the command `sqlite3 person-demo.db`. Then, from inside the sqlite3 console, run the command `select * from person;` (be sure to include the semi-colon!). This should give you the following output:

```sql
1|Bob|22
2|Sue|34
3|Timmy|19
4|Ellen|24
sqlite>  
```

This command selected all the fields (via `*`) for all the records in the Person database. 

We won't be using this database anymore, so let's go ahead and delete everything before moving on. While we could simply delete the sqlitedemo folder and all of its contents, let's take this opportunity to learn one additional SQL command: `drop table`. Still inside the sqlite3 console, drop the person table by running `drop table person;`. Now if you run the `.tables` command, there shouldn't be any listed. You can exit out of sqlite3 by running either `.quit` or `Control-D`. Then, from the command line, you can delete the entire sqlitedemo folder, as we won't be using it anymore.

# Comprehension Questions

1.  What is SQLite?
2.  Explain the difference between vendor-specific and generic SQL commands and give an example of both.
3.  What is the redirection operator used for? Explain when you might use `<` vs. `>`.
4.  How do you open sqlite3 and load a particular database?
5.  How do you quit sqlite3?
6.  How do you show the tables in a given database?
7.  How can you see the details for a given table in an SQLite database.

