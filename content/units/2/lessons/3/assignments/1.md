<!-- 
author: Joe Turner
type: code along
time: 60 minutes
name: Debugging using pdb
 -->

As hard as we try, the code that we write is never perfect. Often we make small mistakes which will either stop our code from running or cause it to produce the wrong result. When this happens we have to work through the code to track down the problem and fix it; this process is known as *debugging*.

You have probably already learned some debugging skills. For example you might have added a `print` statement to some code to try to find out what value a variable held.  In this assignment we will be introducing `pdb`, a new tool which we can use to help us out whilst debugging code.

`pdb` is the Python debugger.  It allows us to pause a Python program whilst it is running to allow us to inspect what is happening.  We can then use it to work through ourr code line-by-line to try to find out where an error is.

# A simple example

Let's set up a simple example program containing a couple of mistakes, which we can use to practice using `pdb`.  Our program is going to be a really simple utility for freelance teams which can divide up an invoice according to how many hours each person spent on a project.

For example imagine that Alice and Bob have done 3 hours of work each and Carol has done 6 hours.  From a $360 invoice Alice and Bob should get $90 each, and Carol should get $180.

Create a new folder called *invoice_calculator*, and inside that create a file called *invoice_calculator.py*.  Then add the following code to the file:

```python
def divide_pay(amount, staff_hours):
    """
    Divide an invoice evenly amongst staff depending on how many hours they
    worked on a project
    """
    total_hours = 0
    for person in staff_hours:
        total_hours += staff_hours[person]

    per_hour = amount * total_hours

    staff_pay = {}
    for person in staff_hours:
        pay = staff_hours[person] / per_hour
        staff_pay[person] = pay

    return staff_pay

def main():
    staff_pay = divide_pay(360.0, {"Alice": 3.0, "Bob": 3.0, "Carol": 6.0})
    for person, pay in staff_pay.iteritems():
        print "{} should be paid ${:.2f}".format(person, pay)

if __name__ == "__main__":
    main()
```

This is our buggy code for working out how the pay should divide.  We create a function called `divide_pay` which takes two arguments: the value of the invoice and a dictionary containg the hours worked on the project.

We use the `staff_hours` dictionary to calculate the total number of hours worked on the project, and use this to work out an hourly rate.  Next we use this hourly rate to work out how much each person should be paid, and add this to the `staff_pay` dictionary.  We then return this dictionary.

In the main function we call the `divide_pay` function for the scenario described earlier.  We then use the returned dictionary to output the pay for each member of the team.

Try running the code using `python debugging.py`.  It should show that no-one should be getting paid anything.  This is clearly a bug, so let's try using `pdb` to fix it.

# Starting PDB

Try running `pdb` by saying `python -m pdb invoice_calculator.py`.  The `-m pdb` option tells Python to run our code using `pdb`.

You should see something like this:

```pdb
> /home/joe/Code/python/thinkful/pip-002-curric-dev/joe-projects/invoice_calculator/invoice_calculator.py(1)<module>()
-> def divide_pay(amount, staff_hours):
(Pdb)
```

The first line here tells us our location within the program.  So at the moment we are in the `<module>` section of *invoice_calculator.py* on line 1; basically in the main body of our file.

The next line contains the line of code that is waiting to be executed.  Here we can see that we are just about to declare the `divide_pay` function.

The last line is a prompt where we can enter commands.

# Navigating your code

Try typing `n` at the prompt and hitting enter.  You should see that the line number has changed and that we are now paused just before where we define the `main` function.

So what has happened here?  At the prompt we entered the `n`, or `next` command.  The command runs a single line of code, then pauses at the line of code which is due to be run next.  We have sucessfully declared the function and are now waiting to declare the next function.  Now press `n` a twice more to declare the function and make it through the `if __name__ == "__main__"` conditional.  You should now be paused just before we call the `main` function.

At this point we could press `n` again.  This would run the `main` function and show us the output.  But that is not very helpful at the moment because we want to see what's happening *inside* the function.  To do that we can use the `s` or `step` command.  Try entering `s` at the prompt:

```pdb
(Pdb) s
--Call--
> /home/joe/Code/python/thinkful/pip-002-curric-dev/joe-projects/invoice_calculator/invoice_calculator.py(19)main()
-> def main():
(Pdb)
```

We can see that `pdb` has called the `main` function, and that we are now paused at the top of the function.  Notice how the location line tells us that we are now inside the `main` function rather than in `<module>`.

From here, enter `n` to take you to where we call the `divide_pay` function, followed by `s` to enter this function.

By this point you have probably forgotten what the `divide_pay` function looks like.  So try hitting `l`, the *list* command.  This prints out the next few lines of code to help us get our bearings as we debug.

Now let's use our `pdb`-fu to jump through to our function and get to the point where we've worked out the total number of hours.  Keep using the `next` command until you are paused at this line:  `per_hour = amount * total_hours`.  If you are getting tired of typing `n` then there is a little shortcut which you can use.  If you hit the enter key it will repeat the last command which you ran.  This means that you can hit `n` once, then keep pressing enter until you reach where you want to be.

Notice how as we stepped through we followed the flow of the code exactly, so we had to step through the `for` loop three times, once for each staff member.

# Finding a bug

Now let's get started trying to work out where our code is going wrong.  Enter `p total_hours` at the prompt.  The `p`, or `print`,  command simply prints out a variable.  You should see that our code thinks that the staff have worked 12 hours in total.  This looks correct, so we need to keep going.

Hit `n` to calculate the hourly rate, then try printing the `per_hour` value.  You should see an hourly rate of $4320.  That looks more like a football player's salary than freelance programming rates.  So we have tracked down a problem - the hourly amount should be the total amount *divided* by the number of hours worked.

Exit `pdb` using the `q` or `quit` command.  Try changing the code to `per_hour = amount / total_hours` and running it again.  Now you should see that Alice and Bob should be given 10c, and Carol should be given 20c.  This isn't quite the $90 and $180 they were expecting.  We clearly still have a bug in our code.

So let's get back into `pdb`.  Start it up again using `python -m pdb invoice_calculator.py`.

# Finding the second bug

As we already know that the first half of our function is correct it seems like a very long-winded process to step through all of our code just to get to where we want to be.  This would be even worse if we had hundreds of staff; imagine having to step through the first `for` loop for each member of staff.

Luckily we don't need to manually step through every line of code when we are debugging.  Instead we can set a *breakpoint*.  Breakpoints instruct `pdb` to pause at a certain point in the code.  So let's set a breakpoint just before the second `for` loop starts.  In your editor look for the line number of the second loop, and set a breakpoint there using `b` or `break` command.  For example `b 12` would tell `pdb` to pause at line 12.

Now let's let our program run until we reach the breakpoint.  Use the `c` or `continue` command to let our code run as normal until we reach the breakpoint.  You should see that we have jumped to the `for person in staff_hours:` line of the `divide_pay` function.

Now let's single-step through the calculations in the `for` loop using the `n` command.  Try printing some variable to make sure they look correct:

```pdb
(Pdb) p person
'Bob'
(Pdb) p staff_hours[person]
3.0
(Pdb) p per_hour
30.0
(Pdb) p pay
0.1
```

Pretty much everything looks right here except for the pay.  And when we double check our pay calculation we can spot the error: the pay should be the hours *multiplied* by the hourly rate.

Try changing the code so that `pay = staff_hours[person] * per_hour`.  Then try running the code again.  You should see that we now calculate the correct values.

As we have seen, pdb is a very powerful tool for inspecting and navigating through code as it runs.  We have gone through the basics of using pdb, but it has a number of additional commands and capabilities which are beyond the scope of this assignment.  These may come in handy when you have a more complex piece of code which you need to debug.  Have a read through the [command reference](https://docs.python.org/2/library/pdb.html#debugger-commands) to see some more of what pdb is capable of.

# Comprehension Questions

1. What do we mean when we say that we are single-stepping in pdb?
2. What is the difference between the `next` command and the `step` command?
3. What is a breakpoint, and how do you create one in in `pdb`?
4. What does the `continue` command do?


