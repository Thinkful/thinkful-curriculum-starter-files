<!-- 
author: Joe Turner
type: code along
time: 60 minutes
name: Using requests to query the GitHub API
 -->

In this lesson we will be applying what you've learned in the previous two assignments to create an application that uses the GitHub API. The application will look at the programming languages which a user has worked with and work out what percentage of their code is written in each language.

# Getting a list of repositories

To get started let's set up a new project.  You will need to:

- Create a folder for the project - `mkdir github_languages`
- Enter the folder - `cd github_langugages`
- Set up a git repository for the project - `git init`
- Create a new virtualenv for the project - `virtualenv env`
- Tell git to ignore the virtualenv - `echo env > .gitignore`
- Activate the virtualenv - `source env/bin/activate`
- Install the requests library - `pip install requests`

Our first challenge is to use the Requests library to access the GitHub API and get a list of a user's repositories. Fortunately the API has an endpoint for doing exactly this. Take a quick look at the [documentation for the endpoint](https://developer.github.com/v3/repos/#list-user-repositories). 

You can see that the endpoint expects a GET request to `/users/<user>/repos`.  So let's try that out just to double check that it works how we expect. Open up a browser and navigate to https://api.github.com/users/YOUR_USERNAME_HERE/repos. You should see a list containing data on of all of your repositories in JSON format.

Now let's try to access the same resource using the requests library. In a file called *github_languages.py* add the following code:

```python
import sys
import operator
from collections import defaultdict

import requests

def get_repositories(user):
    """ Retreive a list of a user's repositories """
    url = "https://api.github.com/users/{user}/repos".format(user=user)
    response = requests.get(url)
    return response.json()

def main():
    """ Main function """
    repositories = get_repositories(sys.argv[1])
    print repositories

if __name__ == "__main__":
    main()
```

First, we import some dependencies for this program. Then we create a `get_repositories` function that takes a GitHub username as an argument. We use this argument to construct the url using the string `format` method. Next we use the `requests.get` function to make the GET request to the endpoint.  Finally we use the `json` method of the response to parse the JSON and return it as a Python list.

We also set up a `main` function which simply calls `get_repositories`, passing in the first command line argument, and prints the returned data. We call the `main` function from the main block of the script.

Try running the program using `python github_languages.py YOUR_GITHUB_USERNAME`. The data printed should be the same as what you saw in the browser earlier.

Before we move on, now would be a good time to commit your work to your Git repository.

# Identifying yourself

Although our code is working fine, that won't last for too long. GitHub pretty heavily limits the number of requests that anonymous users can make to their API. To lift these limits we are going to have to identify ourselves.

Start by creating a new file called *secret.py* in the same folder as *github_langugages.py*.  This file should contain your GitHub username and password:

```python
USERNAME = "alice@example.com"
PASSWORD = "wibble"
```

We can then change our `get_repositories` function to use the credentials from the *secret.py* file when we make our request:

```python
from secret import USERNAME, PASSWORD

def get_repositories(user):
    """ Retreive a list of a user's repositories """
    url = "https://api.github.com/users/{user}/repos".format(user=user)
    response = requests.get(url, auth=(USERNAME, PASSWORD))
    return response.json()
```

Notice how we add the `auth` tuple to the request to tell GitHub who we are.  Try running the code again.  We should now be able to make requests more frequently, and hopefully won't exeed the rate limit while we continue to work on the code.

A very important step which we need to take now is to **tell Git to ignore the *secret.py* file**. Otherwise when you commit the code you risk sharing your username and password with everyone.  On a new line in the *.gitignore* file add `secret.py`. Then try to commit the changes, making sure that the secret.py file is being ignored as expected.


# Getting the languages

Now that we have our list of repositories it's time to get the list of programming languages that each repository contains. In order to do that we will be using [the list langugages endpoint](https://developer.github.com/v3/repos/#list-languages). This expects a GET request to `/repos/<owner>/<repo>/languages`, and returns a dictionary containing the langauges and the corresponding size of the code written in that language.

So let's try adding a function in *github_languages.py* that makes a request to the endpoint for each repository:

```python
def get_language_dictionaries(repositories):
    """
    Return a list of dictionaries containing the languages used in each
    repository
    """
    language_dictionaries = []
    for repository in repositories:
        url = "https://api.github.com/repos/{owner}/{repo}/languages"
        url = url.format(owner=repository["owner"]["login"],
                         repo=repository["name"])
        response = requests.get(url, auth=(USERNAME, PASSWORD))
        language_dictionaries.append(response.json())
    return language_dictionaries
```

The function takes a single argument, which will be the list of repositories that we obtain using the `get_repositories` function. First we create an empty list to hold our language dictionaries.  Next we loop through the list of repositories, and construct the URL which will allow us to access the languages. Inside the loop we make the GET requests, passing in our authorization details as usual. We then add the decoded responses to our list, and finally we return the list.

Now let's modify our main function to try it out:

```python
def main():
    """ Main function """
    repositories = get_repositories(sys.argv[1])
    language_dictionaries = get_language_dictionaries(repositories)
    print language_dictionaries
```

Try running the app using `python github_languages.py YOUR_GITHUB_USERNAME`.  You should see a list of dictionaries containing the language used in each of your repositories.

# Displaying the languages

Now all that is left to do is to work out what percentage of our code was written in each language, and to display it more nicely. First of all let's add a function that calculates the amount of code we've written in each language:

```python
def accumulate_languages(language_dictionaries):
    """ Calculate the total data size for each language """
    accumulated = defaultdict(int)
    total = 0
    for language_dictionary in language_dictionaries:
        for language_name, number_of_bytes in language_dictionary.iteritems():
            accumulated[language_name] += number_of_bytes
            total += number_of_bytes
    return accumulated, total
```

The function takes our list of language dictionaries as its argument. It then creates an instance of the `defaultdict` object to hold the amount of code for each language. The `defualtdict` object works exactly like a regular dictionary, except that if we try to access an element before it has been defined it will create the element for us automatically. For example:

```python
>>> from collections import defaultdict
>>> a = defaultdict(list)
>>> print a["test"]
[]
```

Notice how, despite the fact that we haven't explicitly defined the `test` element of the dictionary, we can still access the element. This is because a default item (in this case a list) has been automatically created.

Returning to our code, our next step after creating the dictionary is to create a variable to hold the total amount of code written. We then loop through the languages using the `iteritems` method of the dictionary object.  This lets us loop through both the keys and the values of the dictionary simultaneously. We add the amount of code to the correct item in the `defaultdict`, and also add it to the total amount of code. Finally we return the dictionary containing the code amounts for each language and the total amount of code.

To finish up we can modify our main function to display the languages and how much they are used:

```python
def main():
    """ Main function """
    repositories = get_repositories(sys.argv[1])
    language_dictionaries = get_language_dictionaries(repositories)
    language_totals, total_bytes = accumulate_languages(language_dictionaries)

    sorted_language_totals = sorted(language_totals.iteritems(),
                                    key=operator.itemgetter(1),
                                    reverse=True)

    for language_name, number_of_bytes in sorted_language_totals:
        percentage = 100.0 * number_of_bytes / total_bytes
        print "{}: {:.2f}%".format(language_name, percentage)
```

First of all we call our `accumulate_languages` function. Next we use the built-in `sorted` method to sort the items in the returned dictionary. We use the `iteritems` method so the sorting process works with a list of tuples containing the language name and the amount of code written in that language.  The `key=operator.itemgetter(1)` argument tells the function to sort the list according to the tuples' second items (i.e. the amount of code). The reverse parameter says that we want our items sorted in descending order; from the language with the most code to the langugage with the least.

We then loop through the sorted list, and calculate the percentage of the total code which is written in each language. Finally we print the language name and the percentage.

Now let's test out our completed app. Try running it with your GitHub username. You should see a list of the languages you've used, along with what percentage of your code is written in it. Also try running it over your mentor's GitHub account to see how you compare.

Don't forget to commit and push your code up to GitHub. That should help to increase the Python percentage!

