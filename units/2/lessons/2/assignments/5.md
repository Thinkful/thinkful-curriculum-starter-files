[//]: <> (author: Joe Turner)
[//]: <> (type: code along)
[//]: <> (time: 60)

# Sourcing the Twitter API

In the previous lesson we learned about how OAuth works.  So now let's try to implement it in practice.  We are going to be building a command-line Twitter client, which uses OAuth to authenticate with the Twitter API.

## Registering an app

The first thing we need to do is to register our app with Twitter.  If you don't have a Twitter account go ahead and sign up for one.  Then sign in and visit the [Twitter app dashboard](https://apps.twitter.com/).  From there you can create a new application.  When you are asked to enter a callback URL leave this blank, as our app will not be using a callback based authentication flow.

When you have created your app jump over to the permissions tab and change the permissions setting to *Read and Write*.  Then take a quick look at the API keys tab.  You should see an API key, and an API secret.  These values are the client key and secret which you read about in the previous lesson.

## Setting up some structure

Now let's get started setting up some structure for our application.  As a first step we can go through the regular project setup process:

```bash
mkdir tweetful
cd tweetful
git init
virtualenv env
echo env > .gitignore
source env/bin/activate
pip install requests requests-oauthlib
```

Notice that along with the requests library we are also installing requests-oauthlib.  This is a library which works with requests to make it simpler to authenticate using OAuth.

As our project is slightly more complex than what we've worked on before we are going to help keep our code organized by splitting it out into separate files.  In all we are going to have four files:

- *tweetful.py* - The main code for the client
- *authorization.py* - The code carrying out the OAuth authorization
- *urls.py* - A file for storing the relevant API endpoint URLs
- *secret.py* - The place to hide our client secret

So let's set up the files with some basic initialization code and some useful imports.

In *tweetful.py* we can add a stub for the main function:

```python
def main():
    """ Main function """
    pass

if __name__ == "__main__":
    main()
```

In *authorize.py* we can add a stub for a method which will authorize the user:

```python
def authorize():
    pass
```

In *urls.py* we can set up the endpoint URLs:

```python
API_URL = "https://api.twitter.com"
REQUEST_TOKEN_URL = API_URL + "/oauth/request_token"
AUTHORIZE_URL = API_URL + "/oauth/authorize?oauth_token={request_token}"
ACCESS_TOKEN_URL = API_URL + "/oauth/access_token"
TIMELINE_URL = API_URL + "/1.1/statuses/home_timeline.json"
TWEET_URL = API_URL + "/1.1/statuses/update.json"
```

And in secret.py we can add our client key and secret, which you can copy from the app dashboard.

```python
CLIENT_KEY = "ABCDEFGHIJKLMNOP123456789"
CLIENT_SECRET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789ABCDEFGHIJKLMNO"
```

Now that we have some basic structure it seems like a good point to commit your work.

## Getting a request token

Next let's get started on our authorization process.  The first thing we need to do is use our client key to get a request token from Twitter.  This allows us to request authorization for the user to access resources.  In your *authorization.py* file create a new function for requesting the token:

```python
import urlparse

import requests
from requests_oauthlib import OAuth1

from secret import CLIENT_KEY, CLIENT_SECRET
from urls import *

def get_request_token():
    """ Get a token allowing us to request user authorization """
    oauth = OAuth1(CLIENT_KEY, client_secret=CLIENT_SECRET)
    response = requests.post(REQUEST_TOKEN_URL,
                             auth=oauth)
    credentials = urlparse.parse_qs(response.content)

    request_token = credentials.get("oauth_token")[0]
    request_secret = credentials.get("oauth_token_secret")[0]
    return request_token, request_secret
```

First of all we create an instance of the `OAuth1` class from the requests_oauthlib library.  We give this the client key and secret from our *secret.py* file.  Then we make a POST request to the request token endpoint passing in the `oauth` object as our authorization credentials.

In the reponse to our request we get a string in `response.contents` which contains the request token and secret as a query string.  We use the `parse_qs` function from Python's `urlparse` module to create a dictionary containing the token and the secret.  Finally we use the dictionaries `get` method to retrieve the items and return them.

Now let's make another couple of slight modification to our code so we can test out our function.  In the `authorize` function we can call our `get_request_token` function and try to print the results:

```python
def authorize():
    """ A complete OAuth authentication flow """
    request_token, request_secret = get_request_token()
    print request_token, request_secret
```

And then in our `main` in *tweetful.py* let's call the `authorize` function:

```python
import authorization

def main():
    """ Main function """
    authorization.authorize()
```

Now try running your code using `python tweetful.py`.  You should see the request token and secret being succesfully retreived and printed.

## Getting the user's permission

Now that we have the ability to request that the user authorizes our app we can direct them to a URL where they can obtain a verification code.  This code is then used when we obtain the access token to confirm that the user is granting the app access to their data.  Let's add another function to *authorization.py* to make that happen.

```python
def get_user_authorization(request_token):
    """
    Redirect the user to authorize the client, and get them to give us the
    verification code.
    """
    authorize_url = AUTHORIZE_URL
    authorize_url = authorize_url.format(request_token=request_token)
    print 'Please go here and authorize: ' + authorize_url
    return raw_input('Please input the verifier: ')
```

Here we construct the authorization URL using the request token which we have obtained from Twitter.  We then ask the user to visit the authorization URL and input the PIN code provided.

Now let's adjust our `authorize` function to try and call this new function:

```python
def authorize():
    """ A complete OAuth authentication flow """
    request_token, request_secret = get_request_token()
    verifier = get_user_authorization(request_token)
```

Try running the app using `python tweetful.py`.  When you are prompted to visit the authorization URL go ahead and follow the link.  You should be able to verify that you want to use the app, and by given a verification code to enter back into the app.

## Getting the access token

Now that we have our verification from the user the final stage of our authentication is to retreive the access token and secret.  These are what we will actually use to obtain access to the API.  In order to obtain the access key we have to make a post request to the access token endpoint.  So let's add a function to *authorization.py* which makes that request:

```python
def get_access_token(request_token, request_secret, verifier):
    """"
    Get a token which will allow us to make requests to the API
    """
    oauth = OAuth1(CLIENT_KEY,
                   client_secret=CLIENT_SECRET,
                   resource_owner_key=request_token,
                   resource_owner_secret=request_secret,
                   verifier=verifier)

    response = requests.post(ACCESS_TOKEN_URL, auth=oauth)
    credentials = urlparse.parse_qs(response.content)
    access_token = credentials.get('oauth_token')[0]
    access_secret = credentials.get('oauth_token_secret')[0]
    return access_token, access_secret
```

Here we construct a new `OAuth1` object which contains our client key and secret, our request token and secret, and the verification code which we obtained from the user.

We then make the request using the `oauth` object as our authorization credentials.  Next we parse the response query string using the `urlparse.parse_qs` function.  We then extract the access token and secret from the `credentials` dictionary and return it.

Now let's add this to our `authorize` function:

```python
def authorize():
    """ A complete OAuth authentication flow """
    request_token, request_secret = get_request_token()
    verifier = get_user_authorization(request_token)
    access_token, access_secret = get_access_token(request_token,
                                                   request_secret,
                                                   verifier)

    oauth = OAuth1(CLIENT_KEY,
                   client_secret=CLIENT_SECRET,
                   resource_owner_key=access_token,
                   resource_owner_secret=access_secret)
    return oauth
```

Here we call our new function passing in the request token, request secret and verification code.  We also create and return a new instance of the `OAuth1` class which uses our access token and secret for authorization.  This can then be used as our credentials to access the API from elsewhere in our client.

Let's try it out by changing the `main` function in *tweetful.py* to request the user's timeline using the API:

```python
def main():
    """ Main function """
    auth = authorization.authorize()

    response = requests.get(TIMELINE_URL, auth=auth)
    print response.json()
```

Here we authorize the application, then use the `OAuth1` instance that is returned to authenticate a request to the user timeline endpoint.  We then print the JSON which is returned by the API.

Try running the code.  You will have to enter a new verification code, but you should see JSON representing your Twitter timeline being output.  This shows that we have succesfully used OAuth to authenticate with the Twitter API.

## Storing and retrieving the access token

Although that all works fine, it's a bit of a pain having to visit the authentication URL every time you try to use your app.  Instead we can save the access token and secret the first time they are provided to us.  Then the next time we use the app we can just load up this data and use it for authentication.

To get this working we can add a couple of methods for saving a loading the information to our *authorization.py* file:

```python
def store_credentials(access_token, access_secret):
    """ Save our access credentials in a json file """
    with open("access.json", "w") as f:
        json.dump({"access_token": access_token,
                   "access_secret": access_secret}, f)

def get_stored_credentials():
    """ Try to retrieve stored access credentials from a json file """
    with open("access.json", "r") as f:
        credentials = json.load(f)
        return credentials["access_token"], credentials["access_secret"]
```

These use the `json` module to store the credentials in a file called *access.py*.  In the `store_credentials` function we open the file for writing, then use the `json.dump` function to write a dictionary to the file as JSON.  In the `get_stored_credentials` function we open the file for reading, then use the `json.load` function to read back the dictionary.  We then return the access token and secret as a tuple.

Finally let's modify the  `authorize` function to use our new functions:

```python
def authorize():
    """ A complete OAuth authentication flow """
    try:
        access_token, access_secret = get_stored_credentials()
    except IOError:
        request_token, request_secret = get_request_token()
        verifier = get_user_authorization(request_token)
        access_token, access_secret = get_access_token(request_token,
                                                       request_secret,
                                                       verifier)
        store_credentials(access_token, access_secret)

    oauth = OAuth1(CLIENT_KEY,
                   client_secret=CLIENT_SECRET,
                   resource_owner_key=access_token,
                   resource_owner_secret=access_secret)
    return oauth
```

First we try to access the stored credentials.  If this throws an `IOError` indicating that the file does not exist, we try to authenticate as before.  If we authenticate correctly then we call the `store_credentials` method to save the access token and secret so we can use them next time.  Finally we return the `OAuth1` object as usual.

Try running your code a couple of times.  The first time you will need to manually authenticate, but the second time it should use our saved credentials.


