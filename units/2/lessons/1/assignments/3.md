[//]: <> (name: Building a command line snippets app)
[//]: <> (author: Joe Turner)
[//]: <> (type: code along)
[//]: <> (time: 60)

# Building a command line snippets app

In the next two assignments we are going to build a simple command line application that will build on your knowledge of the `csv` and the `argparse` libraries. The application will allow you to store and retrieve snippets of text. You can use this to save notes about how Python works as you continue to work through the course.

## Saving snippets

To get started with we are going to look at how to save snippets. We are going to store the snippets in a CSV file using the `csv` module. So lets try to write a function which:

1. Opens a CSV file for writing
2. Writes a snippet of text, with an associated name to the CSV file

First we can create a function stub: a function which is defined but does nothing. This will let us think about the inputs which we need in order to save a snippet. In a file called *snippets.py* try adding the following stub:

```python
def put(name, snippet, filename):
    """ Store a snippet with an associated name in the CSV file """
    pass
```

Notice how our function takes three arguments as inputs; the name of the snippet, the snippet text and a filename where we should store the snippet.

Now we can start to add some functionality. First let's focus on opening the file so we can write our snippets to it:

```python
import csv

def put(name, snippet, filename):
    """ Store a snippet with an associated name in the CSV file """
    with open(filename, "a") as f:
        writer = csv.writer(f)
```

Here we open the file, giving the argument `"a"` to the `open` function to indicate that we want to create the file if it doesn't exist, or append to it otherwise.

We then use the `csv` library to create a writer object. The writer object will allow us to add a new row to the CSV file for each snippet we create. We pass our file in as the `csvfile` argument to the `csv.writer` function, indicating that we want the writer to use our opened file.  Notice how we have added an import statement to allow us to use the `csv` library.

Finally we can think about adding the code which actually adds the snippet to the file:

```python
def put(name, snippet, filename):
    """ Store a snippet with an associated name in the CSV file """
    with open(filename, "a") as f:
        writer = csv.writer(f)
        writer.writerow([name, snippet])
    return name, snippet
```

We use the `writerow` method of the writer object to add a new row to the CSV file.  We pass in a list the the method which contains the name of the snippet and the snippet value.  These will be stored as two separate columns in the file.  

Finally we return a tuple containing the information which we have added.  Returning the information is a fairly common pattern when adding, removing or updating information using a function.  We will see shortly how this helps to clean up our code.

## Trying it out

Now that we have a function to save our snippets, let's try it out.  Open up a terminal in the same directory as your snippets.py folder, and then open up the Python interpreter.  Now try using your function to add a couple of snippets to a file:

```pycon
>>> import snippets
>>> snippets.put("spam", "eggs", "snippets.csv")
('spam', 'eggs')
>>> snippets.put("green eggs", "ham", "snippets.csv")
('green eggs', 'ham')
```

You should see that the *snippets.csv* file has been created in the same directory.  Try opening it up and taking a look at the contents.  There should be two rows, one containing spam and eggs, and the other containing green eggs and ham.  Neat huh?

## Adding a command line interface

Although we now know that our function works, we don't want to have to open up the Python console every time we want to add a snippet.  So let's use the `argparse` module to add a command line interface to our function.

The first stage of this is to work out roughly how we want our interface to look.  The `put` function we have just written takes three arguments, so it seems to make sense to allow three command line arguments.  As we plan to allow snippets to be retrieved as well as set it probably makes sense to add a fourth argument specifying the command type (storage or retrieval).  So let's sketch out a few options for how we could use our app.

```bash 
# Store an item using fully qualified names
python snippets.py --type "put" --name "spam" --snippet "eggs" --filename "snippets.csv"

# Store an item using abbreviations
python snippets.py -t "put" -n "spam" -s "eggs" -f "snippets.csv"

# Have a default argument for filename, so we can leave it empty
python snippets.py -t "put" -n "spam" -s "eggs"

# Use positional rather than optional arguments
python snippets.py put "spam" "eggs" "snippets.csv"

# As above, but with a defualt argument for filename
python snippets.py put "spam" "eggs"
```

Each option has advantages and disadvantages.  For an app as simple as this the use of optional arguments everywhere seems too verbose, even with the abbreviations.  A default filename seems to make sense so you can concentrate on simple adding and retrieving the snippets without worrying about where they are stored.  So for this assignment we will settle on the last option as our ideal syntax.

Now that we have settled on an interface, lets start to build the parser using the `argparse` module.  As a first step we can create a `make_parser` function:

```python
def make_parser():
    """ Construct the command line parser """
    description = "Store and retrieve snippets of text"
    parser = argparse.ArgumentParser(description=description)

    return parser
```
