[//]: <> (name: Building a command line snippets app)
[//]: <> (author: Joe Turner)
[//]: <> (type: code along)
[//]: <> (time: 60)

# Building a command line snippets app

In the next two assignments we are going to build a simple command line application that will build on your knowledge of the `csv` and the `argparse` libraries. The application will allow you to store and retrieve snippets of text. You can use this to save notes about how Python works as you continue to work through the course.

## Saving snippets

To get started with we are going to look at how to save snippets. We are going to store the snippets in a CSV file using the `csv` module. So lets try to write a function which:

1. Opens a CSV file for writing
2. Writes a snippet of text, with an associated name to the CSV file

First we can create a function stub: a function which is defined but does nothing. This will let us think about the inputs which we need in order to save a snippet. In a file called *snippets.py* try adding the following stub:

```python
def put(name, snippet, filename):
    """ Store a snippet with an associated name in the CSV file """
    pass
```

Notice how our function takes three arguments as inputs; the name of the snippet, the snippet text and a filename where we should store the snippet.

Now we can start to add some functionality. First let's focus on opening the file so we can write our snippets to it:

```python
import csv

def put(name, snippet, filename):
    """ Store a snippet with an associated name in the CSV file """
    with open(filename, "a") as f:
        writer = csv.writer(f)
```

Here we open the file, giving the argument `"a"` to the `open` function to indicate that we want to create the file if it doesn't exist, or append to it otherwise.

We then use the `csv` library to create a writer object. The writer object will allow us to add a new row to the CSV file for each snippet we create. We pass our file in as the `csvfile` argument to the `csv.writer` function, indicating that we want the writer to use our opened file.  Notice how we have added an import statement to allow us to use the `csv` library.

Finally we can think about adding the code which actually adds the snippet to the file:

```python
def put(name, snippet, filename):
    """ Store a snippet with an associated name in the CSV file """
    with open(filename, "a") as f:
        writer = csv.writer(f)
        writer.writerow([name, snippet])
    return name, snippet
```

We use the `writerow` method of the writer object to add a new row to the CSV file.  We pass in a list the the method which contains the name of the snippet and the snippet value.  These will be stored as two separate columns in the file.  

Finally we return a tuple containing the information which we have added.  Returning the information is a fairly common pattern when adding, removing or updating information using a function.  We will see shortly how this helps to clean up our code.

## Trying it out

Now that we have a function to save our snippets, let's try it out.  Open up a terminal in the same directory as your snippets.py folder, and then open up the Python interpreter.  Now try using your function to add a couple of snippets to a file:

```pycon
>>> import snippets
>>> snippets.put("spam", "eggs", "snippets.csv")
('spam', 'eggs')
>>> snippets.put("green eggs", "ham", "snippets.csv")
('green eggs', 'ham')
```

You should see that the *snippets.csv* file has been created in the same directory.  Try opening it up and taking a look at the contents.  There should be two rows, one containing spam and eggs, and the other containing green eggs and ham.  Neat huh?

## Adding a command line interface

Although we now know that our function works, we don't want to have to open up the Python console every time we want to add a snippet.  So let's use the `argparse` module to add a command line interface to our function.

The first stage of this is to work out roughly how we want our interface to look.  The `put` function we have just written takes three arguments, so it seems to make sense to allow three command line arguments.  As we plan to allow snippets to be retrieved as well as set it probably makes sense to add a fourth argument specifying the command type (storage or retrieval).  So let's sketch out a few options for how we could use our app.

```bash 
# Store an item using fully qualified names
python snippets.py --type "put" --name "spam" --snippet "eggs" --filename "snippets.csv"

# Store an item using abbreviations
python snippets.py -t "put" -n "spam" -s "eggs" -f "snippets.csv"

# Have a default argument for filename, so we can leave it empty
python snippets.py -t "put" -n "spam" -s "eggs"

# Use positional rather than optional arguments
python snippets.py put spam eggs snippets.csv

# As above, but with a defualt argument for filename
python snippets.py put spam eggs
```

Each option has advantages and disadvantages.  For an app as simple as this the use of optional arguments everywhere seems too verbose, even with the abbreviations.  A default filename seems to make sense so you can concentrate on simple adding and retrieving the snippets without worrying about where they are stored.  So for this assignment we will settle on the last option as our ideal syntax.

Now that we have settled on an interface, lets start to build the parser using the `argparse` module.  As a first step we can create a `make_parser` function:

```python
def make_parser():
    """ Construct the command line parser """
    description = "Store and retrieve snippets of text"
    parser = argparse.ArgumentParser(description=description)

    return parser
```

Here we create an instance fo the `ArgumentParser` object from the `argparse` module.  Note that you will need to add an import statement for `argparse` so we can access this object.  We then simply return the parser object so we can use it later on to parse the command line arguments.

Now let's add a main function to the bottom of *snippets.py* which will create our parser and try to parse the command line arguments.

```python
def main():
    """ Main function """
    parser = make_parser()
    arguments = parser.parse_args(sys.argv[1:])

if __name__ == "__main__":
    main()
```

The main function uses our `make_parser` function to create the command line parser.  We then call the `parse_args` method of the parser, passing in all of the command line arguments we have provided except the first one.  The first argument of `argv` always contains the name of our program which we don't want to try to parse.

Also at this point we have added a main block to the app which calls our main function.  This means that we can start to try running our script.  Open up a terminal and try to run it by saying `python snippets.py --help`.  You should see some help text which has been automatically generated for us by the parser object.

## Making our interface accept arguments

Now that we have a parser let's start building up our interface.  As a first step we are going to split our parser into subparsers - one for the storage command and one for the retrieval command.  This is similar to have apps like `git` work, with different commands taking different arguments.

```python
def make_parser():
    """ Construct the command line parser """
    description = "Store and retrieve snippets of text"
    parser = argparse.ArgumentParser(description=description)

    subparsers = parser.add_subparsers(help="Available commands")

    # Subparser for the put command
    put_parser = subparsers.add_parser("put", help="Store a snippet")

    return parser
```

Here we use the `add_subparsers` method of the parser to allow us to add multiple subparsers.  We then use the `add_parser` method of the `subparsers` object to create our new subparser.  This subparser works in the same way as a standard `ArgumentParser` instance, allowing us to add arguments.  So let's try to expand our function even further to add in the arguments for a put command:

```python
def make_parser():
    """ Construct the command line parser """
    description = "Store and retrieve snippets of text"
    parser = argparse.ArgumentParser(description=description)

    subparsers = parser.add_subparsers(help="Available commands")

    # Subparser for the put command
    put_parser = subparsers.add_parser("put", help="Store a snippet")
    put_parser.add_argument("name", help="The name of the snippet")
    put_parser.add_argument("snippet", help="The snippet text")
    put_parser.add_argument("filename", default="snippets.txt", nargs="?",
                            help="The snippet filename")
    put_parser.set_defaults(command="put")

    return parser
```

Here we use the `add_argument` method to add the three positional arguments.  For the filename argument we give two additional options to the `add_argument` method.  We use the `default` argument to set the default filename.  The `nargs="?"` option says that we can leave out the argument if we just want to use the default value.

Finally we use the `set_defaults` method to add a default argument which is contained every time we perform a put command.  This is helpful as it allows us to work out which command was entered after the parsing has taken place.

Now let's try it out.  In a terminal we can run the program a few different ways to check that our parser works:

```console
# Shows the help for which subcommands are available
python snippets.py --help

# Show the help for the put subcommand
python snippets.py put --help

# Standard put command
python snippets.py put spam eggs

# Put command with an optional filename
python snippets.py put spam eggs test.py

# Put command missing an argument (this should fail)
python snippets.py put spam
```

## Putting it all together

Now that we have both our functionality and our interface, all that remains is to join the two together.  So let's try to extend our `main` function:

```python
def main():
    """ Main function """
    parser = make_parser()
    arguments = parser.parse_args(sys.argv[1:])
    # Convert parsed arguments from Namespace to dictionary
    arguments = vars(arguments)
    command = arguments.pop("command")

    if command == "put":
        name, snippet = put(**arguments)
        print "Stored '{}' as '{}'".format(snippet, name)
```

There are a few things which might be new to you in this code.  Firstly we use the built in `vars` function to convert the `Namespace` object returned by `parse_args` into a dictionary.  This is purely for convenience, as the dictionary object is somewhat easier to work with.

Next we use the `pop` method of the dictionary.  This removes and returns the `command` item which we added earlier to distinguish between the two commands.

We then call our `put` function, using `**arguments` as an argument.  The use of the double-star operator in this context is known as *unpacking*.  If converts the key-value pairs in the dictionary into keyword arguments to the function.  Fo example:

```
# Code without argument unpacking
put(name="spam", snippet="eggs", filename="snippets.py")

# Identical code which uses argument unpacking
arguments = {
    "name": "spam",
    "snippet": "eggs",
    "filename": "snippets.py"
}
put(**arguments)
```

Try running you app and using it to add items to a CSV file.  Open up the file to make sure that the items are being added correctly.  If so, congratulations - that's the first part of our app finished.
