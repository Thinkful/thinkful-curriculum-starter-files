[//]: <> (name: Writing your first endpoints )
[//]: <> (author: Joe Turner)
[//]: <> (type: code along)
[//]: <> (time: 60)

# Writing your first endpoints

Over the next three lessons we will be creating a simple publishing API, which lets you store and retrieve posts.  It could be used as the basis for a blog, CRM or eBook.

In this first lesson we will look at how to write endpoints (URLs designed so you can access and modify data) to retrieve either a list of all of the posts, or a single specific post.

**TODO**: Add url for repo

So we can get started as quickly as possible there is a git repository with a basic framework already set out available from [GitHub](https://github.com/WHAT).  To get started you should:

1. Create a clone of the repository (`git clone WHAT`)
2. Move into the project's directory (`cd WHAT`)
3. Set up a virtualenv for the project (`virtualenv env`)
4. Activate the virtualenv (`source env/bin/activate`)
5. Install the project's dependencies (`pip install -r requirements.txt`)

## Test first

The first endpoint we are going to work on will return a list of posts in JSON format.

**A note on JSON:** JSON is a serialization format which allows us to encode and decode data easily in pretty much any programming language.  It has become a kind of lingua-franca of the web, and you will find that most APIs work with JSON encoded data.

As always we will start with a test.  In the *tests/api_tests.py* file there is a test fixture already set up.  We are going to add a test to this which check that:

- A request to our endpoint is successful
- The endpoint is returning JSON as expected
- The endpoint returns an empty list, as we have no posts

The test should look something like:

```python
    def testGetEmptyPosts(self):
        """ Getting posts from an empty database """
        response = self.client.get("/api/posts")

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.mimetype, "application/json")

        data = json.loads(response.data)
        self.assertEqual(data, [])
```

Add this to the TestAPI class, and try running the test by saying `nosetests tests`.  The test should fail at the first assertion; this is what we would expect as we haven't written the endpoint yet.

There are a few things to notice here:

1. We are using the test client to make a GET request to `/api/posts`. This should give you a clue towards what our endpoint route will look like.
2. We check that the status returned by our endpoint is `200 OK`.  This means that our request has worked correctly.
3. We check the that the endpoint has returned JSON by looking at the response mimetype.  Again, this should give you a hint towards something we might need in our endpoint.
4. We decode the response data using `json.loads`.
5. We check that the JSON contains an empty list.

## Making it pass

Now we have our test in place let's try to make it pass.  The first thing to do is to set up our route in the *posts/api.py* file.  This should look something like:

```python
@app.route("/api/posts", methods=["GET"])
def posts_get():
    """ Get a list of posts """
    pass
```

Notice how we use the methods parameter to specify that this endpoint will only handle GET requests.

Now let's add a body to our function which will return the empty list as JSON:

```python
@app.route("/api/posts", methods=["GET"])
def posts_get():
    """ Get a list of posts """
    data = json.dumps([])
    return Response(data, 200, mimetype="application/json")
```

Here we manually construct a Response object which returns:

- An empty list encoded as JSON using `json.dumps`.
- A status of 200 OK
- The correct mimetype for JSON

Try running your test again (`nosetests tests`).  Hopefully it will pass this time.  If so, congratulations - you've just written your first API endpoint!

## Adding a model

**QUESTION**: Are we using Alembic for migrations?

Now we know the basics of how to construct an endpoint let's expand our code a little to make it work with some actual data.  The first step towards this is to create a SQLAlchemy model to represent our posts.  To keep things simple we will keep our model to three fields: an id, the post title, and some body text.

The *posts/database.py* already contains the setup code for a database connection, so all we need to do is add the following to our *posts/models.py* file:

```python
class Post(Base):
    __tablename__ = "posts"

    id = Column(Integer, Sequence('post_id_sequence'), primary_key=True)
    title = Column(String(128))
    body = Column(String(1024))
```

**TODO**: Unit/Lesson number for models

This should all look pretty familiar to you.  If not have a quick look back over WHAT.

At this stage we can also add one final piece of code which will come in handy shortly.  To allow us to easily convert our SQLAlchemy model into JSON we will add an `asDictionary` method, which will return a post's data as a Python dictionary.  This should look something like:

```python
    def asDictionary(self):
        post = {
            "id": self.id,
            "title": self.title,
            "body": self.body
        }
        return post
```

## A trickier test

Now that we have our model in place, let's make a new test which adds a couple of posts and makes sure that our endpoint returns them correctly.

First let's create the test in *tests/api_tests.py* and add code to create the posts:

```python
    def testGetPosts(self):
        """ Getting posts from a populated database """
        postA = models.Post(title="Example Post A", body="Just a test")
        postB = models.Post(title="Example Post B", body="Still a test")

        session.add_all([postA, postB])
        session.commit()
```

Then we can copy the request and assertions from `testEmptyPosts`, changing the code so that it checks that the posts are returned correctly:

```python
        response = self.client.get("/api/posts",
            headers=[("Accept", "application/json")]
        )

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.mimetype, "application/json")

        data = json.loads(response.data)
        self.assertEqual(len(data), 2)

        postA = data[0]
        self.assertEqual(postA["title"], "Example Post A")
        self.assertEqual(postA["body"], "Just a test")

        postB = data[1]
        self.assertEqual(postB["title"], "Example Post B")
        self.assertEqual(postB["body"], "Still a test")
```

Try running the tests again.  This new test should make it past where we check the status and mimetype of the response.  It should only fail when we start to check that the correct data was returned.

## Returning data

Now let's try to update our endpoint so that it passes this more complex test.  In order to make the test pass our endpoint needs to:

- Query the database for all of the posts
- Convert the list of posts to JSON
- Return this list in our response

The modified endpoint should look something like this:

```python
@app.route("/api/posts", methods=["GET"])
def posts_get():
    # Get the posts from the database
    posts = session.query(models.Post).all()

    # Convert the posts to JSON and return a response
    data = json.dumps([post.asDictionary() for post in posts])
    return Response(data, 200, mimetype="application/json")
```

Notice how we use the `asDictionary` method in a list comprehension to create a list of dictionaries containing the data for the posts.  You may be wondering why we don't just call `json.dumps(posts)` to encode our posts as JSON.  Unfortunately this will not work because the `json` module does not know how to serialize SQLAlchemy models correctly.  Our solution is to convert our data to Python dictionaries, which the `json` module is happy to serialize.

Try running the tests again.  Hopefully the second test will now pass, showing that we can retrieve a list of posts from our API.


## GETting a single post

## Good behaviour



Write tests for a /posts and /posts/id endpoint checking that they:

- 	Return empty JSON
- 	Have the correct mimetype set
- 	Write minimal endpoints
- 	Return empty list and dictionary at first
- 	Update tests for some example data
- 	Update endpoints so they return the correct data
- 	Add accept header to test
- 	Add accept decorator to endpoint
