<!-- 
author: Benjamin White
type: content
time: 30 minutes
name: Basic Data Types
 -->
To be productive in a programming language, you need to have a clear understanding of its basic data types. This means knowing the syntax for working with them and their characteristics and behaviors. We'll cover these basics in this reading, and you are advised to make these part of your working mental map. 

So far, we've encountered strings, numbers, booleans, and datetime objects. The first three of these can be called *simple data types* in Python. We'll contrast these with Python's more complex data types for dealing with *collections*. 

For this rest of this reading, keep a python terminal running from the command line (just run `python` from the command line) so you can try out the examples. Since we're discussing data types in this reading, we'll use the built in Python `type()` function to see the type of variables we've assigned. 

# Simple Types

Python features four simple data types: boolean, strings, numbers, and **none**, which we haven't yet encountered. 

## booleans 

As we already saw, the boolean data type can take on two possible values: **True** and **False**. Inside of your python console, create a new variable *t* whose value is *True*: `t = True`. After that run `type(t)`. As you'll see, t's type is 'bool' (short for boolean). 

Simply assigning the values True and False to variables would not be very useful. The power of booleans comes from using comparison and logical operators. We've alrady seen how we can use arithmetic operators like +, -, *, and / in Python to work with numbers. We use comparison and logical operators for working with logical relations. 

Python offers the comparison operators listed below. For each one, we provide a code sample you can input in your Python terminal. Assume for all samples that we've defined two variables `a = 10` and `b = 12`:  

*  **== equal** |  `a == b` will evaluate to False and `a == a` will evalute to True.
*   **!= not equal** | `a != b` will evaluate to True and `a != a` will evalute to False.
*   **> greater than** | `a > b` will evaluate to False.
*   **< less than** | `a < b` will evaluate to True
*   **>= greater than or equal** | `a >= a` will evaluate to True
*   **>= less than or equal** | `b <= a` will evaluate to False

If you input these examples into a Python terminal, you'll see that they evaluate to true and false. But you can also assign each of the preceding expressions to variables. So you could do `answer = a >= b`, for instance, and then if you typed `answer`, you'd get `False`.

Python also gives us the following keywords for combining booleans and logical conditions:

*   **and** | `(a == a) and (b != a)` will evaluate to True because both of the conditions are true.
*   **or**  | `(a == b) or (b == b)` will evaluate to True because one of the conditions is true.
*   **not** | `not(True)` evaluates to False and `not(a != a)` evaluates to True. 

We'll encounter booleans again and again in the remainder of this course, and you'll use them in your programs to determine how your program responds in different conditions.

## strings 

Along with numbers, strings are probably the most intuitive data type  to understand in Python. A string simply represents text. We've already seen how all strings have some built in methods we can call on them. So if we had `my_string = 'abcdefg'`, we could then get an uppercase version by running `my_string.uppercase()`. 

All strings also have a length, which we can access by using the built in `len()` function. So `len(my_string)` would return 7 because our string is seven characters long.  

We've also seen how you can access sub-strings by indexing (`'my-substring'[:2]` would result in 'substring') and how you can combine strings together using *concatenation*. 

Finally we got our first taste of string formatting in the exercises at Codeacademy in the first lesson of this course. Later in this lesson, you'll learn how to use Python's `.format()` for string formatting.


## numbers

We've already encountered numbers and arithmetic operators in Python. So far, we've come across two types of numbers: integers (e.g., 2) and floats (e.g., 2.0). 

In addition to these two number types, Python also has **long** integers, which can be used to represent very large or very small (i.e., negative) numbers. We won't discuss long integers in this course, but it's good to know about them in case you see them in the wild. To make a value a long integer, simply add 'L' to the end of it: given `x = 1L`, `type(x)` evaluates to 'long'. 

Finally, Python also can work with *complex* or *imaginary* numbers. These are not commonly used in Python programming, and we won't encounter them in this course. 


## None 

The final simple data type to discuss is `None`. This is a distinct data type in Python, on the same order as strings, floats, or integers. `None` is used to represent the absence of a value. In your Python terminal, if you assign `x = None`, and then do `type(x)`, you'll see that x's type is the NoneType. We'll encounter practical uses for none throughout this course. For now, just know that this data type exists and that it's used to indicate the absence of a value.


# Collections of Things: Lists, Tuples and Dictionaries

Much of programming has to do with dealing with collections of things. It might be collections of rows from a data base, or collections of numbers that we want to sum together, or something else entirely. Chances are though, if you're writing software, some part of your application will work with collections of things. 

In Python, you can have collections of different types of things. If you wanted to have a list of all numbers, you could do that, but you could also have a list whose items are numbers, strings, and even other lists. 

The most commonly used Python data types for working with collections are lists, tuples, and dictionaries. We'll explore lists and dictionaries in depth later in this lesson. For now, here's the big picture for each one.

- **lists** Lists can hold collections of objects. The syntax for creating a list is `my_list = [1, 2, 'three', 'four']`. The key here is the square brackets and comma separation for list items. Like strings, lists can be sliced using the `[m:n]` syntax we saw earlier, and to access a specific item in a list you refer to it by index. Given *my_list* above, `my_list[0]` would return 1. You can also add and remove items from lists once they've been created: for instance `my_list.append(5)`. We'll explore lists in greater depth later in this lesson. 

- **tuples** Tuples are similar to lists except you can't add or remove items from them once they're created. The syntax for tuples uses parentheses: `my_tuple = (1, 2, 3, 'four')`. That's about all you need to know about tuples for now.

- **dictionaries** Dictionaries are like lists in that they are *mutable* (that is, you can alter them after they've been created), but they map *keys* to *values* in the same way that dictionary books map words to meanings. We can create dictionary like this: `my_dictionary = {'a': 1, 'b': 'two'}`. Then we could get a's value with `my_dictionary['a']`. For now, it's enough to know what a dictionary is and how it differs from a list. We'll explore dictionaries more deeply later in this lesson.

If you already know a bit about Python, you may be aware that Python also features functions and objects as data types. These are indeed distinct data types in Python, but they are more complex and are comprised of these primary types. Rest assured we'll cover both functions and objects in depth later in this unit.

# Comprehension Check

1.  What are Python's primary data types?
2.  What's the difference between a tuple and a list?
3.  What's a dictionary?
4.  How can you tell the type of a variable?
5.  What is the purpose of None in Python?
6.  Make sure you've memorized the comparison and logical operators for booleans.
