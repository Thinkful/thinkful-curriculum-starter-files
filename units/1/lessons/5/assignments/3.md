[//]: <> (author: Benjamin White)
[//]: <> (type: content)
[//]: <> (time: 30)

# Functions and Side Effects in Python

One of the great things about functions is that they (generally) don’t have side effects. When you program with functions, you pass some variables into a function, you get a return value from the function and usually it won’t change anything else in your application. This is a good thing as it makes it very easy to reason about how your system will work and you don’t get surprised when one part of your application unexpectedly changes another part. In fact there is a whole trend towards functional programming (using special languages like Haskell or Clojure) which takes this to its logical extreme and is a really good way to solve a lot of programming problems.

In Python (and many other languages), however, things aren’t that simple. Sometimes functions do have side-effects and you need to know when they will so you don’t get surprised by how your code ends up working.

### Simple objects don’t get changed

Save the following code into a file called number.py and look at the output:

    my_number = 10
    
    def change(a_number):
      a_number = 3
    
    print(my_number)
    change(my_number)
    print(my_number)

When you run `python number.py`, unexpectedly, it prints out 10 twice. Why? Because when my_number is passed into the change function, any changes made to the local variable (called a_number) don’t affect the my_number variable. There are no side effects.

## Complex objects do get changed

Save the following code into a file called object.py and look at the output:

# Creating a user class
class User(object):
 def __init__(self, name):
   self.name = name
 def introduce(self):
   print "My name is ", self.name

# Defining a function that will take a string and object and 
# modify them locally
def change(string, object):
  string = "new name"
  object.name = "another new name"

# Creating our user and string
fred = User("fred")
bill = "bill"

# Showing their current values
fred.introduce()
print bill

# Calling the function that makes changes to them locally
change(bill, fred)

# Showing their values after the change
fred.introduce()
print bill

When you run python object.py, you’ll see that while value of the string didn’t get changed, but the name property of the object did. Take a minute, run the code, play with it a bit and really let this sink in. Even though you passed the object to a function and gave it a different name there, the changes still affected the variable outside of the function. This is something that it is really important to remember.

What gets affected?
Take some time to create new python scripts for doing this to booleans, lists, sets, tuples and dictionaries. In each case make some change to the object within the change() method and see whether or not the value of the variable outside of the function changed.

Why does this happen?
In Python, you have names and bindings. In our number example, the name “my_number” gets bound to a memory location where we are storing the 10. When we pass the variable into a function, a new name (a_number) is also set to point to that same memory location containing the 10. If we do something like adding a 1 to the 10 within the function, numbers are immutable, so it creates a new number (11) and stores that in memory, and points the new name (a_number) to the 11. However, if we just call a method on an object, that simply updates the object in place and both of the names for that object (in our object example, “fred” and “object”) still point to the new, updated object.

The key thing to understand here is that sometimes the objects we pass into functions may be modified by those functions and we need to bear that in mind when writing our programs.