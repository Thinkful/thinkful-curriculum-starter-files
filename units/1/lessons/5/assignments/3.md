[//]: <> (author: Benjamin White)
[//]: <> (type: 3pc)
[//]: <> (time: 60)

# Principles of Object Oriented Programming

interfaces/ DRY in your methods / single sources of truth / sensical method signatures / loose coupling. / callers

*   Must cover Python properties, and public vs. private in earlier units


This distinction between public and private methods on a class is a critical one. When you’re designing a class, you’ll often have methods that are internal to the class that you don’t want the outside world to know about, either because they do something very specific that the outside world is unlikely to need, or because they’re likely to change, and so you don’t want the outside world depending on these methods. These private methods are really about implementation, and you should limit public knowledge of implementation, because it leads to more tightly coupled code. A public method, in contrast, is one that you’re saying the outside world can count on as providing a dependable sort of behavior. Your tests document these public methods and tell the outside world that it can depend on these methods existing in the future.

We say that objects are composite because they can combine the simple data types we’ve studied so far: strings, numbers, and functions. Recall that a variable is simply a name that points at a value. That value can be a string, a number, or a function. You’ve also learned about scope. Scope refers to the level in a hierarchy at which a set of variable names refer to a respective set of values. These two concepts are brought together in objects. An object combines a set of properties and methods (the term we use for functions defined on an object) into a common namespace. That means if you define the property “foo” on some object—object1 - to be “bar”, and and the property “foo” on another object—object2—to be “manchu”, object1.foo’s value will be “bar” while object2.foo's will be "manchu". Each object separately binds the variable “foo” to a unique name space.
Another key characteristic of objects is that they allow for classes and inheritance. You can think of a class as a generic type of object, such as a car. You can then have individual instances of cars (which themselves might be grouped by class, such as convertible, station wagon, etc.). In JavaScript, one class can inherit from another. Imagine that you have an Quadruped (that is, 4-legged creature) class. All members of this class share the property of having four legs, and share the methods of being able to walk and run. Now imagine you want to create another class for dogs. Because they’re a type of quadruped, dogs should also have 4 legs and be able to walk and run. We could make our dog class inherit from quadruped, so that it automatically gets 4 legs and walk and run methods, without us having to explicitly write code that sets these characteristics. We could then add methods and properties that are specific to dogs to this class, such as the ability to bark. If we wanted to create a cat class, it could also inherit from Quadruped.
Objects turn out to be incredibly important for modeling real world entities, whether they be things like people or companies, or processes like customer acquisition or particle physics. Object oriented programming (that is, using objects to model things in our applications) can be challenging to first learn, but it’s a powerful programming technique that is critical to learn if you want to become a professional developer.

## Comprehension Check

1. a
2. b
3. c
4. d
5. e
6. f


