[//]: <> (name: Follow Up: )
[//]: <> (author: Iain Duncan)
[//]: <> (type: 3pc)
[//]: <> (time: 30)

# Follow Up: TBD


Now, in a real world database for a critical operation, such as listing the pets
available for adoption, normalization raises some new issues:

 * What happens to the pet_person table if we delete a person?
 * What happens to our pet and breed tables if we delete a breed?
 * What *should* happen to our pet table if we delete a breed that has pets? Should this even be possible?
 * What happens if we enter garbage integer data into any of our foreign key columns?
 
The issues are important to consider in designing a database. At present, if we
delete a pet who had one or more people, we'll have some nonsensical entries hanging around
in our person_pet association table.
Worse, if we delete a species, we'll have invalid entries in the breed table, where we'll
have species_id columns referencing non-existing Species entries. These problems are called
data consistency problems. They put our database in such a state that it represents a nonsensical
real world state. This sort of problem can be especially difficult to debug as our 
program may not have any *programming errors* per se, but the outcomes will be incorrect. 

To solve these sorts of  issues, database systems allow us to specify what are called
**Foreign Key Constraints**.
We can tell the database that a foreign key column *must* refer to a valid related entry, 
or that certain operations should not be permitted, or that certain operations should automatically
trigger other operations. For example, we
could specify a foreign key constraint that says that we can not delete a species entry
if any breeds are still referencing it. Or we could alternately specify that deleting a species
entry automatically deletes all breeds referring to it. Or that breeds referring to it should have
their foreign keys changed to Null. 

These sort of rules are referred to as "The Cascade", we specify
how changes should *cascade* to their related dependent entries in other tables. And to do so, we need to 
spend some time thinking about what is logical for our specific data model. For example, sometimes
it makes sense that a foreign key could be null, and other times that is obviously a mistake. If 
we add a pet shelter table to our database, and add a relationship between the pet table and the shelter 
table, we can see that it makes sense that:

  - a shelter can have many pets
  - a pet only comes from one shelter
  - but a pet may also not come from any shelter, thus null is a possible valid value

The syntax for specifying foreing key constraints in SQL can be a bit involved, and enabling
foreign key constraints in sqlite requires some extra configuration, so we will not get into
the details at this point. We will be coming back to the cascade in further detail in subsequent
lessons however. And even if we don't specify constraints at this time, it's important to 
understand the ramifications of normalization when designing any system using a relational data model. 

Part 3 Exercises
----------------
- go to https://www.sqlite.org/foreignkeys.html and read Section 1, "Introduction to Foreign Key Constraints",
  and section 4.3 "ON DELETE and ON UPDATE Actions" 
- add a shelter table, with values for name, address, phone number, website
- update our pet table without recreating it to include a foreing key reference to the shelter
  that a pet is at or is from
- what do you think *should* happen (or be prevented) in we attempt the following:
    - deleting a species?
    - deleting a shelter? 
    - deleting a person?
- how is the foreign key relationship for pet to pet shelter different than from pet to breed? What
  would we need to specify to make this clear?